{"version":3,"sources":["../src/index.js"],"names":["tags","require","bytes","SOIMarkerLength","JPEGSOIMarker","TIFFINTEL","TIFFMOTOROLA","APPMarkerLength","APPMarkerBegin","APPMarkerEnd","isValid","buffer","SOIMarker","readUInt16BE","e","Error","isTiff","checkAPPn","APPMarkerTag","isInRange","IFDHandler","tagCollection","order","offset","entriesNumber","readUInt16LE","entriesNumberLength","entries","slice","entryLength","exif","entryCount","entryBegin","entry","tagBegin","tagLength","dataFormatBegin","dataFormatLength","componentsBegin","componentsNumberLength","dataValueBegin","dataValueLength","tagAddress","tagNumber","toString","reverse","tagName","bigDataFormat","littleDataFormat","dataFormat","componentsByte","bigComponentsNumber","readUInt32BE","littleComponentNumber","readUInt32LE","componentsNumber","dataLength","dataValue","dataOffset","tagValue","readUInt8","replace","i","length","bigTagValue","littleTagValue","push","bigOrder","readInt32BE","littleOrder","readInt32LE","EXIFHandler","buf","pad","data","lengthLength","identifierLength","padLength","byteOrderLength","byteOrder","fortyTwoLength","fortyTwoEnd","big42","little42","offsetOfIFD","ifd","ExifIFDPointer","SubExif","GPSInfoIFDPointer","gps","GPSInfo","APPnHandler","fromBuffer","sync","file","fs","readFileSync","async","callback","Promise","resolve","reject","readFile","err","error","undefined","then","d","catch","exports","parse","parseSync"],"mappings":"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","file":"index.js","sourcesContent":["import fs from \"fs\";\n\nconst tags = require(\"./tags.json\");\n\n/*\n unsignedByte,\n asciiStrings,\n unsignedShort,\n unsignedLong,\n unsignedRational,\n signedByte,\n undefined,\n signedShort,\n signedLong,\n signedRational,\n singleFloat,\n doubleFloat\n */\nconst bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];\nconst SOIMarkerLength = 2;\nconst JPEGSOIMarker = 0xffd8;\nconst TIFFINTEL = 0x4949;\nconst TIFFMOTOROLA = 0x4d4d;\nconst APPMarkerLength = 2;\nconst APPMarkerBegin = 0xffe0;\nconst APPMarkerEnd = 0xffef;\n\n/**\n * @param buffer {Buffer}\n * @returns {Boolean}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var isImage = isValid(content);\n * console.log(isImage);\n */\nconst isValid = (buffer) => {\n  try {\n    const SOIMarker = buffer.readUInt16BE(0);\n    return SOIMarker === JPEGSOIMarker;\n  } catch (e) {\n    throw new Error(\"Unsupport file format.\");\n  }\n};\n/**\n * @param buffer {Buffer}\n * @returns {Boolean}\n * @example\n */\nconst isTiff = (buffer) => {\n  try {\n    const SOIMarker = buffer.readUInt16BE(0);\n    return SOIMarker === TIFFINTEL || SOIMarker === TIFFMOTOROLA;\n  } catch (e) {\n    throw new Error(\"Unsupport file format.\");\n  }\n};\n/**\n * @param buffer {Buffer}\n * @returns {Number}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var APPNumber = checkAPPn(content);\n * console.log(APPNumber);\n */\nconst checkAPPn = (buffer) => {\n  try {\n    const APPMarkerTag = buffer.readUInt16BE(0);\n    const isInRange =\n      APPMarkerTag >= APPMarkerBegin && APPMarkerTag <= APPMarkerEnd;\n    return isInRange ? APPMarkerTag - APPMarkerBegin : false;\n  } catch (e) {\n    throw new Error(\"Invalid APP Tag.\");\n  }\n};\n/**\n * @param buffer {Buffer}\n * @param tagCollection {Object}\n * @param order {Boolean}\n * @param offset {Number}\n * @returns {Object}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = IFDHandler(content, 0, true, 8);\n * console.log(exifFragments.value);\n */\nconst IFDHandler = (buffer, tagCollection, order, offset) => {\n  const entriesNumber = order ? buffer.readUInt16BE(0) : buffer.readUInt16LE(0);\n\n  if (entriesNumber === 0) {\n    return {};\n  }\n\n  const entriesNumberLength = 2;\n  const entries = buffer.slice(entriesNumberLength);\n  const entryLength = 12;\n  // let nextIFDPointerBegin = entriesNumberLength + entryLength * entriesNumber;\n  // let bigNextIFDPointer= buffer.readUInt32BE(nextIFDPointerBegin) ;\n  // let littleNextIFDPointer= buffer.readUInt32LE(nextIFDPointerBegin);\n  // let nextIFDPointer = order ?bigNextIFDPointer:littleNextIFDPointer;\n  const exif = {};\n  let entryCount = 0;\n\n  for (entryCount; entryCount < entriesNumber; entryCount += 1) {\n    const entryBegin = entryCount * entryLength;\n    const entry = entries.slice(entryBegin, entryBegin + entryLength);\n    const tagBegin = 0;\n    const tagLength = 2;\n    const dataFormatBegin = tagBegin + tagLength;\n    const dataFormatLength = 2;\n    const componentsBegin = dataFormatBegin + dataFormatLength;\n    const componentsNumberLength = 4;\n    const dataValueBegin = componentsBegin + componentsNumberLength;\n    const dataValueLength = 4;\n    const tagAddress = entry.slice(tagBegin, dataFormatBegin);\n    const tagNumber = order\n      ? tagAddress.toString(\"hex\")\n      : tagAddress.reverse().toString(\"hex\");\n    const tagName = tagCollection[tagNumber];\n    const bigDataFormat = entry.readUInt16BE(dataFormatBegin);\n    const littleDataFormat = entry.readUInt16LE(dataFormatBegin);\n    const dataFormat = order ? bigDataFormat : littleDataFormat;\n    const componentsByte = bytes[dataFormat];\n    const bigComponentsNumber = entry.readUInt32BE(componentsBegin);\n    const littleComponentNumber = entry.readUInt32LE(componentsBegin);\n    const componentsNumber = order\n      ? bigComponentsNumber\n      : littleComponentNumber;\n    const dataLength = componentsNumber * componentsByte;\n    let dataValue = entry.slice(\n      dataValueBegin,\n      dataValueBegin + dataValueLength\n    );\n\n    if (dataLength > 4) {\n      const dataOffset =\n        (order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0)) -\n        offset;\n      dataValue = buffer.slice(dataOffset, dataOffset + dataLength);\n    }\n\n    let tagValue;\n\n    if (tagName) {\n      switch (dataFormat) {\n        case 1:\n          tagValue = dataValue.readUInt8(0);\n          break;\n        case 2:\n          tagValue = dataValue.toString(\"ascii\").replace(/\\0+$/, \"\");\n          break;\n        case 3:\n          tagValue = order\n            ? dataValue.readUInt16BE(0)\n            : dataValue.readUInt16LE(0);\n          break;\n        case 4:\n          tagValue = order\n            ? dataValue.readUInt32BE(0)\n            : dataValue.readUInt32LE(0);\n          break;\n        case 5:\n          tagValue = [];\n\n          for (let i = 0; i < dataValue.length; i += 8) {\n            const bigTagValue =\n              dataValue.readUInt32BE(i) / dataValue.readUInt32BE(i + 4);\n            const littleTagValue =\n              dataValue.readUInt32LE(i) / dataValue.readUInt32LE(i + 4);\n            tagValue.push(order ? bigTagValue : littleTagValue);\n          }\n\n          break;\n        case 7:\n          switch (tagName) {\n            case \"ExifVersion\":\n              tagValue = dataValue.toString();\n              break;\n            case \"FlashPixVersion\":\n              tagValue = dataValue.toString();\n              break;\n            case \"SceneType\":\n              tagValue = dataValue.readUInt8(0);\n              break;\n            default:\n              tagValue = `0x${dataValue.toString(\"hex\", 0, 15)}`;\n              break;\n          }\n          break;\n        case 10: {\n          const bigOrder = dataValue.readInt32BE(0) / dataValue.readInt32BE(4);\n          const littleOrder =\n            dataValue.readInt32LE(0) / dataValue.readInt32LE(4);\n          tagValue = order ? bigOrder : littleOrder;\n          break;\n        }\n        default:\n          tagValue = `0x${dataValue.toString(\"hex\")}`;\n          break;\n      }\n      exif[tagName] = tagValue;\n    }\n    /*\n     else {\n     console.log(`Unkown Tag [0x${tagNumber}].`);\n     }\n     */\n  }\n  return exif;\n};\n\n/**\n * @param buf {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = EXIFHandler(content);\n */\nconst EXIFHandler = (buf, pad = true) => {\n  let data = {};\n  let buffer = buf;\n\n  if (pad) {\n    buffer = buf.slice(APPMarkerLength);\n    const length = buffer.readUInt16BE(0);\n    buffer = buffer.slice(0, length);\n    const lengthLength = 2;\n    buffer = buffer.slice(lengthLength);\n    const identifierLength = 5;\n    buffer = buffer.slice(identifierLength);\n    const padLength = 1;\n    buffer = buffer.slice(padLength);\n  }\n\n  const byteOrderLength = 2;\n  const byteOrder = buffer.toString(\"ascii\", 0, byteOrderLength) === \"MM\";\n  const fortyTwoLength = 2;\n  const fortyTwoEnd = byteOrderLength + fortyTwoLength;\n  const big42 = buffer.readUInt32BE(fortyTwoEnd);\n  const little42 = buffer.readUInt32LE(fortyTwoEnd);\n  const offsetOfIFD = byteOrder ? big42 : little42;\n\n  buffer = buffer.slice(offsetOfIFD);\n\n  if (buffer.length > 0) {\n    data = IFDHandler(buffer, tags.ifd, byteOrder, offsetOfIFD);\n\n    if (data.ExifIFDPointer) {\n      buffer = buffer.slice(data.ExifIFDPointer - offsetOfIFD);\n      data.SubExif = IFDHandler(\n        buffer,\n        tags.ifd,\n        byteOrder,\n        data.ExifIFDPointer\n      );\n    }\n\n    if (data.GPSInfoIFDPointer) {\n      const gps = data.GPSInfoIFDPointer;\n      buffer = buffer.slice(\n        data.ExifIFDPointer ? gps - data.ExifIFDPointer : gps - offsetOfIFD\n      );\n      data.GPSInfo = IFDHandler(buffer, tags.gps, byteOrder, gps);\n    }\n  }\n\n  return data\n};\n\n/**\n * @param buffer {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = APPnHandler(content);\n */\nconst APPnHandler = (buffer) => {\n  const APPMarkerTag = checkAPPn(buffer);\n\n  if (APPMarkerTag !== false) {\n    // APP0 is 0, and 0==false\n    const length = buffer.readUInt16BE(APPMarkerLength);\n\n    switch (APPMarkerTag) {\n      case 1: // EXIF\n        return EXIFHandler(buffer);\n      default:\n        return APPnHandler(buffer.slice(APPMarkerLength + length));\n    }\n  }\n};\n\n/**\n * @param buffer {Buffer}\n * @returns {Object}\n * @example\n */\nconst fromBuffer = (buffer) => {\n  if (!buffer) {\n    throw new Error(\"buffer not found\");\n  }\n\n  let data;\n\n  if (isValid(buffer)) {\n    buffer = buffer.slice(SOIMarkerLength);\n    data = APPnHandler(buffer);\n  } else if (isTiff(buffer)) {\n    data = EXIFHandler(buffer, false);\n  }\n\n  return data;\n};\n\n/**\n * @param file {String}\n * @returns {Object}\n * @example\n * var exif = sync(\"~/Picture/IMG_1981.JPG\");\n * console.log(exif.createTime);\n */\nconst sync = (file) => {\n  if (!file) {\n    throw new Error(\"File not found\");\n  }\n\n  const buffer = fs.readFileSync(file);\n\n  return fromBuffer(buffer);\n};\n\n/**\n * @param file {String}\n * @param callback {Function}\n * @example\n * async(\"~/Picture/IMG_0707.JPG\", (err, data) => {\n *     if(err) {\n *         console.log(err);\n *     }\n *     if(data) {\n *         console.log(data.ExifOffset.createTime);\n *     }\n * }\n */\nconst async = (file, callback) => {\n  let data;\n\n  new Promise(\n    (resolve, reject) => {\n      if (!file) {\n        reject(new Error(\"❓File not found.\"));\n      }\n\n      fs.readFile(file, (err, buffer) => {\n        if (err) {\n          reject(err);\n        } else {\n          try {\n            if (isValid(buffer)) {\n              const buf = buffer.slice(SOIMarkerLength);\n\n              data = APPnHandler(buf);\n\n              resolve(data);\n            } else if (isTiff(buffer)) {\n              data = EXIFHandler(buffer, false);\n\n              resolve(data);\n            } else {\n              reject(new Error(\"😱Unsupport file type.\"));\n            }\n          } catch (e) {\n            reject(e);\n          }\n        }\n      });\n    },\n    (error) => {\n      callback(error, undefined);\n    }\n  )\n    .then((d) => {\n      callback(undefined, d);\n    })\n    .catch((error) => {\n      callback(error, undefined);\n    });\n};\n\nexports.fromBuffer = fromBuffer;\nexports.parse = async;\nexports.parseSync = sync;\n"]}