{"version":3,"sources":["../src/index.js"],"names":["tags","require","bytes","SOIMarkerLength","JPEGSOIMarker","APPMarkerLength","APPMarkerBegin","APPMarkerEnd","data","isValid","buffer","SOIMarker","readUInt16BE","e","Error","checkAPPn","APPMarkerTag","isInRange","IFDHandler","tagCollection","order","offset","entriesNumber","readUInt16LE","entriesNumberLength","entries","slice","entryLength","exif","entryCount","entryBegin","entry","tagBegin","tagLength","dataFormatBegin","dataFormatLength","componentsBegin","componentsNumberLength","dataValueBegin","dataValueLength","tagAddress","tagNumber","toString","reverse","tagName","bigDataFormat","littleDataFormat","dataFormat","componentsByte","bigComponentsNumber","readUInt32BE","littleComponentNumber","readUInt32LE","componentsNumber","dataLength","dataValue","dataOffset","tagValue","readUInt8","replace","i","length","bigTagValue","littleTagValue","push","bigOrder","readInt32BE","littleOrder","readInt32LE","EXIFHandler","buf","lengthLength","identifierLength","padLength","byteOrderLength","byteOrder","fortyTwoLength","fortyTwoEnd","big42","little42","offsetOfIFD","ifd","ExifIFDPointer","SubExif","GPSInfoIFDPointer","gps","GPSInfo","APPnHandler","sync","file","undefined","fs","readFileSync","async","callback","Promise","resolve","reject","readFile","err","error","then","d","catch","exports","parse","parseSync"],"mappings":";;AAAA;;;;;;AAEA,IAAMA,OAAOC,QAAQ,aAAR,CAAb;;AAEA;;;;;;;;;;;;;;AAcA,IAAMC,QAAQ,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAAkC,CAAlC,EAAqC,CAArC,CAAd;AACA,IAAMC,kBAAkB,CAAxB;AACA,IAAMC,gBAAgB,MAAtB;AACA,IAAMC,kBAAkB,CAAxB;AACA,IAAMC,iBAAiB,MAAvB;AACA,IAAMC,eAAe,MAArB;AACA,IAAIC,aAAJ;AACA;;;;;;;;AAQA,SAASC,OAAT,CAAiBC,MAAjB,EAAyB;AACvB,MAAI;AACF,QAAMC,YAAYD,OAAOE,YAAP,CAAoB,CAApB,CAAlB;AACA,WAAOD,cAAcP,aAArB;AACD,GAHD,CAGE,OAAOS,CAAP,EAAU;AACV,UAAM,IAAIC,KAAJ,CAAU,wBAAV,CAAN;AACD;AACF;AACD;;;;;;;;AAQA,SAASC,SAAT,CAAmBL,MAAnB,EAA2B;AACzB,MAAI;AACF,QAAMM,eAAeN,OAAOE,YAAP,CAAoB,CAApB,CAArB;AACA,QAAMK,YAAYD,gBAAgBV,cAAhB,IAAkCU,gBAAgBT,YAApE;AACA,WAAOU,YAAYD,eAAeV,cAA3B,GAA4C,KAAnD;AACD,GAJD,CAIE,OAAOO,CAAP,EAAU;AACV,UAAM,IAAIC,KAAJ,CAAU,kBAAV,CAAN;AACD;AACF;AACD;;;;;;;;;;;AAWA,SAASI,UAAT,CAAoBR,MAApB,EAA4BS,aAA5B,EAA2CC,KAA3C,EAAkDC,MAAlD,EAA0D;AACxD,MAAMC,gBAAgBF,QAAQV,OAAOE,YAAP,CAAoB,CAApB,CAAR,GAAiCF,OAAOa,YAAP,CAAoB,CAApB,CAAvD;AACA,MAAID,kBAAkB,CAAtB,EAAyB;AACvB,WAAO,EAAP;AACD;AACD,MAAME,sBAAsB,CAA5B;AACA,MAAMC,UAAUf,OAAOgB,KAAP,CAAaF,mBAAb,CAAhB;AACA,MAAMG,cAAc,EAApB;AACA;AACA;AACA;AACA;AACA,MAAMC,OAAO,EAAb;AACA,MAAIC,aAAa,CAAjB;AACA,OAAKA,UAAL,EAAiBA,aAAaP,aAA9B,EAA6CO,cAAc,CAA3D,EAA8D;AAC5D,QAAMC,aAAaD,aAAaF,WAAhC;AACA,QAAMI,QAAQN,QAAQC,KAAR,CAAcI,UAAd,EAA0BA,aAAaH,WAAvC,CAAd;AACA,QAAMK,WAAW,CAAjB;AACA,QAAMC,YAAY,CAAlB;AACA,QAAMC,kBAAkBF,WAAWC,SAAnC;AACA,QAAME,mBAAmB,CAAzB;AACA,QAAMC,kBAAkBF,kBAAkBC,gBAA1C;AACA,QAAME,yBAAyB,CAA/B;AACA,QAAMC,iBAAiBF,kBAAkBC,sBAAzC;AACA,QAAME,kBAAkB,CAAxB;AACA,QAAMC,aAAaT,MAAML,KAAN,CAAYM,QAAZ,EAAsBE,eAAtB,CAAnB;AACA,QAAMO,YAAYrB,QAAQoB,WAAWE,QAAX,CAAoB,KAApB,CAAR,GAAqCF,WAAWG,OAAX,GAAqBD,QAArB,CAA8B,KAA9B,CAAvD;AACA,QAAME,UAAUzB,cAAcsB,SAAd,CAAhB;AACA,QAAMI,gBAAgBd,MAAMnB,YAAN,CAAmBsB,eAAnB,CAAtB;AACA,QAAMY,mBAAmBf,MAAMR,YAAN,CAAmBW,eAAnB,CAAzB;AACA,QAAMa,aAAa3B,QAAQyB,aAAR,GAAwBC,gBAA3C;AACA,QAAME,iBAAiB9C,MAAM6C,UAAN,CAAvB;AACA,QAAME,sBAAsBlB,MAAMmB,YAAN,CAAmBd,eAAnB,CAA5B;AACA,QAAMe,wBAAwBpB,MAAMqB,YAAN,CAAmBhB,eAAnB,CAA9B;AACA,QAAMiB,mBAAmBjC,QAAQ6B,mBAAR,GAA8BE,qBAAvD;AACA,QAAMG,aAAaD,mBAAmBL,cAAtC;AACA,QAAIO,YAAYxB,MAAML,KAAN,CAAYY,cAAZ,EAA4BA,iBAAiBC,eAA7C,CAAhB;AACA,QAAIe,aAAa,CAAjB,EAAoB;AAClB,UAAME,aAAa,CAACpC,QAAQmC,UAAUL,YAAV,CAAuB,CAAvB,CAAR,GAAoCK,UAAUH,YAAV,CAAuB,CAAvB,CAArC,IAAkE/B,MAArF;AACAkC,kBAAY7C,OAAOgB,KAAP,CAAa8B,UAAb,EAAyBA,aAAaF,UAAtC,CAAZ;AACD;AACD,QAAIG,iBAAJ;AACA,QAAIb,OAAJ,EAAa;AACX,cAAQG,UAAR;AACE,aAAK,CAAL;AACEU,qBAAWF,UAAUG,SAAV,CAAoB,CAApB,CAAX;AACA;AACF,aAAK,CAAL;AACED,qBAAWF,UAAUb,QAAV,CAAmB,OAAnB,EAA4BiB,OAA5B,CAAoC,MAApC,EAA4C,EAA5C,CAAX;AACA;AACF,aAAK,CAAL;AACEF,qBAAWrC,QAAQmC,UAAU3C,YAAV,CAAuB,CAAvB,CAAR,GAAoC2C,UAAUhC,YAAV,CAAuB,CAAvB,CAA/C;AACA;AACF,aAAK,CAAL;AACEkC,qBAAWrC,QAAQmC,UAAUL,YAAV,CAAuB,CAAvB,CAAR,GAAoCK,UAAUH,YAAV,CAAuB,CAAvB,CAA/C;AACA;AACF,aAAK,CAAL;AACEK,qBAAW,EAAX;AACA,eAAK,IAAIG,IAAI,CAAb,EAAgBA,IAAIL,UAAUM,MAA9B,EAAsCD,KAAK,CAA3C,EAA8C;AAC5C,gBAAME,cAAcP,UAAUL,YAAV,CAAuBU,CAAvB,IAA4BL,UAAUL,YAAV,CAAuBU,IAAI,CAA3B,CAAhD;AACA,gBAAMG,iBAAiBR,UAAUH,YAAV,CAAuBQ,CAAvB,IAA4BL,UAAUH,YAAV,CAAuBQ,IAAI,CAA3B,CAAnD;AACAH,qBAASO,IAAT,CAAc5C,QAAQ0C,WAAR,GAAsBC,cAApC;AACD;AACD;AACF,aAAK,CAAL;AACE,kBAAQnB,OAAR;AACE,iBAAK,aAAL;AACEa,yBAAWF,UAAUb,QAAV,EAAX;AACA;AACF,iBAAK,iBAAL;AACEe,yBAAWF,UAAUb,QAAV,EAAX;AACA;AACF,iBAAK,WAAL;AACEe,yBAAWF,UAAUG,SAAV,CAAoB,CAApB,CAAX;AACA;AACF;AACED,gCAAgBF,UAAUb,QAAV,CAAmB,KAAnB,EAA0B,CAA1B,EAA6B,EAA7B,CAAhB;AACA;AAZJ;AAcA;AACF,aAAK,EAAL;AAAS;AACP,gBAAMuB,WAAWV,UAAUW,WAAV,CAAsB,CAAtB,IAA2BX,UAAUW,WAAV,CAAsB,CAAtB,CAA5C;AACA,gBAAMC,cAAcZ,UAAUa,WAAV,CAAsB,CAAtB,IAA2Bb,UAAUa,WAAV,CAAsB,CAAtB,CAA/C;AACAX,uBAAWrC,QAAQ6C,QAAR,GAAmBE,WAA9B;AACA;AACD;AACD;AACEV,4BAAgBF,UAAUb,QAAV,CAAmB,KAAnB,CAAhB;AACA;AA7CJ;AA+CAd,WAAKgB,OAAL,IAAgBa,QAAhB;AACD;AACD;;;;;AAKD;AACD,SAAO7B,IAAP;AACD;;AAED;;;;;;;AAOA,SAASyC,WAAT,CAAqBC,GAArB,EAA0B;AACxB,MAAI5D,SAAS4D,IAAI5C,KAAJ,CAAUrB,eAAV,CAAb;AACA,MAAMwD,SAASnD,OAAOE,YAAP,CAAoB,CAApB,CAAf;AACAF,WAASA,OAAOgB,KAAP,CAAa,CAAb,EAAgBmC,MAAhB,CAAT;AACA,MAAMU,eAAe,CAArB;AACA7D,WAASA,OAAOgB,KAAP,CAAa6C,YAAb,CAAT;AACA,MAAMC,mBAAmB,CAAzB;AACA9D,WAASA,OAAOgB,KAAP,CAAa8C,gBAAb,CAAT;AACA,MAAMC,YAAY,CAAlB;AACA/D,WAASA,OAAOgB,KAAP,CAAa+C,SAAb,CAAT;AACA,MAAMC,kBAAkB,CAAxB;AACA,MAAMC,YAAYjE,OAAOgC,QAAP,CAAgB,OAAhB,EAAyB,CAAzB,EAA4BgC,eAA5B,MAAiD,IAAnE;AACA,MAAME,iBAAiB,CAAvB;AACA,MAAMC,cAAcH,kBAAkBE,cAAtC;AACA,MAAME,QAAQpE,OAAOwC,YAAP,CAAoB2B,WAApB,CAAd;AACA,MAAME,WAAWrE,OAAO0C,YAAP,CAAoByB,WAApB,CAAjB;AACA,MAAMG,cAAcL,YAAYG,KAAZ,GAAoBC,QAAxC;AACArE,WAASA,OAAOgB,KAAP,CAAasD,WAAb,CAAT;AACA,MAAItE,OAAOmD,MAAP,GAAgB,CAApB,EAAuB;AACrBrD,WAAOU,WAAWR,MAAX,EAAmBV,KAAKiF,GAAxB,EAA6BN,SAA7B,EAAwCK,WAAxC,CAAP;AACA,QAAIxE,KAAK0E,cAAT,EAAyB;AACvBxE,eAASA,OAAOgB,KAAP,CAAalB,KAAK0E,cAAL,GAAsBF,WAAnC,CAAT;AACAxE,WAAK2E,OAAL,GAAejE,WAAWR,MAAX,EAAmBV,KAAKiF,GAAxB,EAA6BN,SAA7B,EAAwCnE,KAAK0E,cAA7C,CAAf;AACD;AACD,QAAI1E,KAAK4E,iBAAT,EAA4B;AAC1B,UAAMC,MAAM7E,KAAK4E,iBAAjB;AACA1E,eAASA,OAAOgB,KAAP,CAAalB,KAAK0E,cAAL,GAAsBG,MAAM7E,KAAK0E,cAAjC,GAAkDG,MAAML,WAArE,CAAT;AACAxE,WAAK8E,OAAL,GAAepE,WAAWR,MAAX,EAAmBV,KAAKqF,GAAxB,EAA6BV,SAA7B,EAAwCU,GAAxC,CAAf;AACD;AACF;AACF;;AAED;;;;;;;AAOA,SAASE,WAAT,CAAqB7E,MAArB,EAA6B;AAC3B,MAAMM,eAAeD,UAAUL,MAAV,CAArB;AACA,MAAIM,iBAAiB,KAArB,EAA4B;AAAE;AAC5B,QAAM6C,SAASnD,OAAOE,YAAP,CAAoBP,eAApB,CAAf;AACA,YAAQW,YAAR;AACE,WAAK,CAAL;AAAQ;AACNqD,oBAAY3D,MAAZ;AACA;AACF;AACE6E,oBAAY7E,OAAOgB,KAAP,CAAarB,kBAAkBwD,MAA/B,CAAZ;AACA;AANJ;AAQD;AACF;;AAED;;;;;;;AAOA,SAAS2B,IAAT,CAAcC,IAAd,EAAoB;AAClB,MAAI,CAACA,IAAL,EAAW;AACT,UAAM,IAAI3E,KAAJ,CAAU,gBAAV,CAAN;AACD;AACDN,SAAOkF,SAAP;AACA,MAAIhF,SAASiF,aAAGC,YAAH,CAAgBH,IAAhB,CAAb;AACA,MAAIhF,QAAQC,MAAR,CAAJ,EAAqB;AACnBA,aAASA,OAAOgB,KAAP,CAAavB,eAAb,CAAT;AACAK,WAAO,EAAP;AACA+E,gBAAY7E,MAAZ;AACD;AACD,SAAOF,IAAP;AACD;;AAED;;;;;;;;;;;;;AAaA,SAASqF,KAAT,CAAeJ,IAAf,EAAqBK,QAArB,EAA+B;AAC7BtF,SAAOkF,SAAP;AACA,MAAIK,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/B,QAAI,CAACR,IAAL,EAAW;AACTQ,aAAO,IAAInF,KAAJ,CAAU,kBAAV,CAAP;AACD;AACD6E,iBAAGO,QAAH,CAAYT,IAAZ,EAAkB,UAACU,GAAD,EAAMzF,MAAN,EAAiB;AACjC,UAAIyF,GAAJ,EAAS;AACPF,eAAOE,GAAP;AACD,OAFD,MAEO;AACL,YAAI;AACF,cAAI1F,QAAQC,MAAR,CAAJ,EAAqB;AACnB,gBAAM4D,MAAM5D,OAAOgB,KAAP,CAAavB,eAAb,CAAZ;AACAK,mBAAO,EAAP;AACA+E,wBAAYjB,GAAZ;AACA0B,oBAAQxF,IAAR;AACD,WALD,MAKO;AACLyF,mBAAO,IAAInF,KAAJ,CAAU,wBAAV,CAAP;AACD;AACF,SATD,CASE,OAAOD,CAAP,EAAU;AACVoF,iBAAOpF,CAAP;AACD;AACF;AACF,KAjBD;AAkBD,GAtBD,EAsBG,UAACuF,KAAD,EAAW;AACZN,aAASM,KAAT,EAAgBV,SAAhB;AACD,GAxBD,EAwBGW,IAxBH,CAwBQ,UAACC,CAAD,EAAO;AACbR,aAASJ,SAAT,EAAoBY,CAApB;AACD,GA1BD,EA0BGC,KA1BH,CA0BS,UAACH,KAAD,EAAW;AAClBN,aAASM,KAAT,EAAgBV,SAAhB;AACD,GA5BD;AA6BD;;AAEDc,QAAQC,KAAR,GAAgBZ,KAAhB;AACAW,QAAQE,SAAR,GAAoBlB,IAApB","file":"index.js","sourcesContent":["import fs from 'fs';\n\nconst tags = require('./tags.json');\n\n/*\n unsignedByte,\n asciiStrings,\n unsignedShort,\n unsignedLong,\n unsignedRational,\n signedByte,\n undefined,\n signedShort,\n signedLong,\n signedRational,\n singleFloat,\n doubleFloat\n */\nconst bytes = [0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8];\nconst SOIMarkerLength = 2;\nconst JPEGSOIMarker = 0xffd8;\nconst APPMarkerLength = 2;\nconst APPMarkerBegin = 0xffe0;\nconst APPMarkerEnd = 0xffef;\nlet data;\n/**\n * @param buffer {Buffer}\n * @returns {Boolean}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var isImage = isValid(content);\n * console.log(isImage);\n */\nfunction isValid(buffer) {\n  try {\n    const SOIMarker = buffer.readUInt16BE(0);\n    return SOIMarker === JPEGSOIMarker;\n  } catch (e) {\n    throw new Error('Unsupport file format.');\n  }\n}\n/**\n * @param buffer {Buffer}\n * @returns {Number}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var APPNumber = checkAPPn(content);\n * console.log(APPNumber);\n */\nfunction checkAPPn(buffer) {\n  try {\n    const APPMarkerTag = buffer.readUInt16BE(0);\n    const isInRange = APPMarkerTag >= APPMarkerBegin && APPMarkerTag <= APPMarkerEnd;\n    return isInRange ? APPMarkerTag - APPMarkerBegin : false;\n  } catch (e) {\n    throw new Error('Invalid APP Tag.');\n  }\n}\n/**\n * @param buffer {Buffer}\n * @param tagCollection {Object}\n * @param order {Boolean}\n * @param offset {Number}\n * @returns {Object}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = IFDHandler(content, 0, true, 8);\n * console.log(exifFragments.value);\n */\nfunction IFDHandler(buffer, tagCollection, order, offset) {\n  const entriesNumber = order ? buffer.readUInt16BE(0) : buffer.readUInt16LE(0);\n  if (entriesNumber === 0) {\n    return {};\n  }\n  const entriesNumberLength = 2;\n  const entries = buffer.slice(entriesNumberLength);\n  const entryLength = 12;\n  // let nextIFDPointerBegin = entriesNumberLength + entryLength * entriesNumber;\n  // let bigNextIFDPointer= buffer.readUInt32BE(nextIFDPointerBegin) ;\n  // let littleNextIFDPointer= buffer.readUInt32LE(nextIFDPointerBegin);\n  // let nextIFDPointer = order ?bigNextIFDPointer:littleNextIFDPointer;\n  const exif = {};\n  let entryCount = 0;\n  for (entryCount; entryCount < entriesNumber; entryCount += 1) {\n    const entryBegin = entryCount * entryLength;\n    const entry = entries.slice(entryBegin, entryBegin + entryLength);\n    const tagBegin = 0;\n    const tagLength = 2;\n    const dataFormatBegin = tagBegin + tagLength;\n    const dataFormatLength = 2;\n    const componentsBegin = dataFormatBegin + dataFormatLength;\n    const componentsNumberLength = 4;\n    const dataValueBegin = componentsBegin + componentsNumberLength;\n    const dataValueLength = 4;\n    const tagAddress = entry.slice(tagBegin, dataFormatBegin);\n    const tagNumber = order ? tagAddress.toString('hex') : tagAddress.reverse().toString('hex');\n    const tagName = tagCollection[tagNumber];\n    const bigDataFormat = entry.readUInt16BE(dataFormatBegin);\n    const littleDataFormat = entry.readUInt16LE(dataFormatBegin);\n    const dataFormat = order ? bigDataFormat : littleDataFormat;\n    const componentsByte = bytes[dataFormat];\n    const bigComponentsNumber = entry.readUInt32BE(componentsBegin);\n    const littleComponentNumber = entry.readUInt32LE(componentsBegin);\n    const componentsNumber = order ? bigComponentsNumber : littleComponentNumber;\n    const dataLength = componentsNumber * componentsByte;\n    let dataValue = entry.slice(dataValueBegin, dataValueBegin + dataValueLength);\n    if (dataLength > 4) {\n      const dataOffset = (order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0)) - offset;\n      dataValue = buffer.slice(dataOffset, dataOffset + dataLength);\n    }\n    let tagValue;\n    if (tagName) {\n      switch (dataFormat) {\n        case 1:\n          tagValue = dataValue.readUInt8(0);\n          break;\n        case 2:\n          tagValue = dataValue.toString('ascii').replace(/\\0+$/, '');\n          break;\n        case 3:\n          tagValue = order ? dataValue.readUInt16BE(0) : dataValue.readUInt16LE(0);\n          break;\n        case 4:\n          tagValue = order ? dataValue.readUInt32BE(0) : dataValue.readUInt32LE(0);\n          break;\n        case 5:\n          tagValue = [];\n          for (let i = 0; i < dataValue.length; i += 8) {\n            const bigTagValue = dataValue.readUInt32BE(i) / dataValue.readUInt32BE(i + 4);\n            const littleTagValue = dataValue.readUInt32LE(i) / dataValue.readUInt32LE(i + 4);\n            tagValue.push(order ? bigTagValue : littleTagValue);\n          }\n          break;\n        case 7:\n          switch (tagName) {\n            case 'ExifVersion':\n              tagValue = dataValue.toString();\n              break;\n            case 'FlashPixVersion':\n              tagValue = dataValue.toString();\n              break;\n            case 'SceneType':\n              tagValue = dataValue.readUInt8(0);\n              break;\n            default:\n              tagValue = `0x${dataValue.toString('hex', 0, 15)}`;\n              break;\n          }\n          break;\n        case 10: {\n          const bigOrder = dataValue.readInt32BE(0) / dataValue.readInt32BE(4);\n          const littleOrder = dataValue.readInt32LE(0) / dataValue.readInt32LE(4);\n          tagValue = order ? bigOrder : littleOrder;\n          break;\n        }\n        default:\n          tagValue = `0x${dataValue.toString('hex')}`;\n          break;\n      }\n      exif[tagName] = tagValue;\n    }\n    /*\n     else {\n     console.log(`Unkown Tag [0x${tagNumber}].`);\n     }\n     */\n  }\n  return exif;\n}\n\n/**\n * @param buf {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = EXIFHandler(content);\n */\nfunction EXIFHandler(buf) {\n  let buffer = buf.slice(APPMarkerLength);\n  const length = buffer.readUInt16BE(0);\n  buffer = buffer.slice(0, length);\n  const lengthLength = 2;\n  buffer = buffer.slice(lengthLength);\n  const identifierLength = 5;\n  buffer = buffer.slice(identifierLength);\n  const padLength = 1;\n  buffer = buffer.slice(padLength);\n  const byteOrderLength = 2;\n  const byteOrder = buffer.toString('ascii', 0, byteOrderLength) === 'MM';\n  const fortyTwoLength = 2;\n  const fortyTwoEnd = byteOrderLength + fortyTwoLength;\n  const big42 = buffer.readUInt32BE(fortyTwoEnd);\n  const little42 = buffer.readUInt32LE(fortyTwoEnd);\n  const offsetOfIFD = byteOrder ? big42 : little42;\n  buffer = buffer.slice(offsetOfIFD);\n  if (buffer.length > 0) {\n    data = IFDHandler(buffer, tags.ifd, byteOrder, offsetOfIFD);\n    if (data.ExifIFDPointer) {\n      buffer = buffer.slice(data.ExifIFDPointer - offsetOfIFD);\n      data.SubExif = IFDHandler(buffer, tags.ifd, byteOrder, data.ExifIFDPointer);\n    }\n    if (data.GPSInfoIFDPointer) {\n      const gps = data.GPSInfoIFDPointer;\n      buffer = buffer.slice(data.ExifIFDPointer ? gps - data.ExifIFDPointer : gps - offsetOfIFD);\n      data.GPSInfo = IFDHandler(buffer, tags.gps, byteOrder, gps);\n    }\n  }\n}\n\n/**\n * @param buffer {Buffer}\n * @returns {Undefined}\n * @example\n * var content = fs.readFileSync(\"~/Picture/IMG_0911.JPG\");\n * var exifFragments = APPnHandler(content);\n */\nfunction APPnHandler(buffer) {\n  const APPMarkerTag = checkAPPn(buffer);\n  if (APPMarkerTag !== false) { // APP0 is 0, and 0==false\n    const length = buffer.readUInt16BE(APPMarkerLength);\n    switch (APPMarkerTag) {\n      case 1: // EXIF\n        EXIFHandler(buffer);\n        break;\n      default:\n        APPnHandler(buffer.slice(APPMarkerLength + length));\n        break;\n    }\n  }\n}\n\n/**\n * @param file {String}\n * @returns {Object}\n * @example\n * var exif = sync(\"~/Picture/IMG_1981.JPG\");\n * console.log(exif.createTime);\n */\nfunction sync(file) {\n  if (!file) {\n    throw new Error('File not found');\n  }\n  data = undefined;\n  let buffer = fs.readFileSync(file);\n  if (isValid(buffer)) {\n    buffer = buffer.slice(SOIMarkerLength);\n    data = {};\n    APPnHandler(buffer);\n  }\n  return data;\n}\n\n/**\n * @param file {String}\n * @param callback {Function}\n * @example\n * async(\"~/Picture/IMG_0707.JPG\", (err, data) => {\n *     if(err) {\n *         console.log(err);\n *     }\n *     if(data) {\n *         console.log(data.ExifOffset.createTime);\n *     }\n * }\n */\nfunction async(file, callback) {\n  data = undefined;\n  new Promise((resolve, reject) => {\n    if (!file) {\n      reject(new Error('❓File not found.'));\n    }\n    fs.readFile(file, (err, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        try {\n          if (isValid(buffer)) {\n            const buf = buffer.slice(SOIMarkerLength);\n            data = {};\n            APPnHandler(buf);\n            resolve(data);\n          } else {\n            reject(new Error('😱Unsupport file type.'));\n          }\n        } catch (e) {\n          reject(e);\n        }\n      }\n    });\n  }, (error) => {\n    callback(error, undefined);\n  }).then((d) => {\n    callback(undefined, d);\n  }).catch((error) => {\n    callback(error, undefined);\n  });\n}\n\nexports.parse = async;\nexports.parseSync = sync;\n"]}